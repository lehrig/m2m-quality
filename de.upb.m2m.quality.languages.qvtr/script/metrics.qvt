transformation qvtToMetrics(qvt:semanticsQvt, metrics:QVTMetrics){top relation visitFunctions {checkonly domain qvt t : semanticsQvt::model::qvtrelation::RelationalTransformation {    ownedOperation = op : semantics::bridge::DefinedOperation {}};enforce domain metrics m:QVTMetrics::Transformation {    functions = func : QVTMetrics::Function {}};where {    visitFunction(op, func);}}top relation visitRelations {relName:String;checkonly domain qvt t : semanticsQvt::model::qvtrelation::RelationalTransformation {    rule = rul : semanticsQvt::model::qvtbase::Rule     {    	name = relName    }};enforce domain metrics m:QVTMetrics::Transformation {    relations = rel :QVTMetrics::Relation    {    	name = relName    } };when {	if semanticsQvt::model::qvtbase::Function.allInstances()->size() > 0		then visitFunctions(t, m)	else		true	endif;    }where {    visitRelation(rul,rel);    }}top relation visitTransformation{varName : String;ch : Set(semanticsQvt::model::qvtbase::Transformation);checkonly domain qvt t : semanticsQvt::model::qvtrelation::RelationalTransformation {	name = varName};enforce domain metrics m:QVTMetrics::Transformation{ name = varName, noRelations = t.rule->size(), noTopLevelRelations = countTopLevel(t), noLeafRelations = getLeafRelations(t)->size(), noStarts = countStarts(t), noWhen = countWhen(t), noWhere = countWhere(t), noMetamodels = t.modelParameter->size(), noOclQueries = t.ownedOperation->size(), noDirectChildren = collectDirectChildren(t)->size(), noTransitiveChildren = collectChildren(t)->size(),  noTransitiveParents = collectParents(t)->size(), noOverrides = t.rule->collect(i | i._overrides->size())->sum()};when {    visitRelations(t, m);    /* Children already processed */       ch = collectDirectChildren(t);    ch->forAll(i | QVTMetrics::Transformation.allInstances()->exists(e | visitTransformation(i, e)));    }where{	}}top relation calcRelationAvg{varName : String;checkonly domain qvt r : semanticsQvt::model::qvtrelation::Relation {	name = varName	};enforce domain metrics m:QVTMetrics::Relation{	name = varName,	avgSizeOfDomainPattern = m.domainPattern->collect(c | c.sizeOfDomainPattern)->sum() / m.domainPattern->size()};when{	visitRelation(r, m);	}where{}}top relation calcTransAvg{ --rules: OrderedSet(semanticsQvt::model::qvtbase::Rule);checkonly domain qvt t : semanticsQvt::model::qvtrelation::RelationalTransformation {	};enforce domain metrics m:QVTMetrics::Transformation{ avgWhen = calcAvgWhen(m), avgWhere = calcAvgWhere(m), avgNWWP = calcAvgNWWP(m), avgNWWPC = calcAvgNWWPC(m), avgDomains = calcAvgDomains(m), avgSizeOfDomainPattern = AvSDP(t),--calcAvgSizeOfDomainPattern(m),--AvSDP(t),-- avgVars = calcAvgVars(m), avgEnforcedDomains = calcAvgEnforcedDomains(m), avgCheckonlyDomains = calcAvgCheckonlyDomains(m), avgFanIn = calcAvgFanIn(m), avgRelFanOut = calcAvgRelFanOut(m), avgFuncFanOut = calcAvgFuncFanOut(m), avgValOut = calcAvgValOut(m), avgChildComplexity = calcAvgChildComplexity(t), avgVarBindingRate = calcAvgVariableBindingRate(m), avgRelationDependencyDepth = calcAvgRelationDependencyDepth(t), avgTypeOverlap = calcAvgTypeOverlap(t) };when{	visitTransformation(t, m);	calcRelationsAvg(t,m);	--rules = t.rule;    --rules.asSet()->forAll(r | QVTMetrics::Relation.allInstances()->exists(e | calcRelationAvg(r.oclAsType(semanticsQvt::model::qvtrelation::Relation), e)));}}/* Distribution of complexity among children */top relation calcBalance {checkonly domain qvt t : semanticsQvt::model::qvtrelation::RelationalTransformation {};checkonly domain metrics parent:QVTMetrics::Transformation {};enforce domain metrics m:QVTMetrics::Transformation{    balance = calcInheritComplexity(t) / parent.avgChildComplexity};when{    t._extends->size() > 0;    calcTransAvg(t._extends, parent);    calcTransAvg(t, m);}}top relation calcRelationsAvg {varName : String;checkonly domain qvt t : semanticsQvt::model::qvtrelation::RelationalTransformation {    rule = rul : semanticsQvt::model::qvtbase::Rule     {    	name = varName    }};enforce domain metrics m:QVTMetrics::Transformation {    relations = rel :QVTMetrics::Relation    {    name = varName,    isLeaf = getLeafRelations(t)->includes(rul.oclAsType(semanticsQvt::model::qvtrelation::Relation)),    depthOfLeaf = if isLeaf then getDepthOfLeafRelation(rul.oclAsType(semanticsQvt::model::qvtrelation::Relation)) else 0 endif        } };when {	visitRelations(t,m);    calcRelationAvg(rul,rel);}where {	}}relation visitRelation{ relationName :String; 	checkonly domain qvt r:semanticsQvt::model::qvtrelation::Relation {	name = relationName,	_domain = dom : semanticsQvt::model::qvtbase::Domain {}	};enforce domain metrics m:QVTMetrics::Relation{   	name = relationName,	domainPattern = pat : QVTMetrics::DomainPattern 	{		sizeOfDomainPattern = if dom.oclIsTypeOf(semanticsQvt::model::qvtrelation::RelationDomain) then  			countSubExps(dom.oclAsType(semanticsQvt::model::qvtrelation::RelationDomain).pattern.templateExpression)			else 			0			endif	},	noCheckonlyDomains = r._domain->select(isCheckable)->size(),	noEnforcedDomains = r._domain->select(isEnforcable)->size(),	noDomains = r._domain->size(), /* noDomains == valIn */	noVars = r.variable->reject(v| semanticsQvt::model::qvttemplate::ObjectTemplateExp.allInstances().bindsTo->includes(v) )->size(),	noUnboundVars = getUnboundVariables(r)->size(), 	noBoundVars = r.variable->reject(v| getUnboundVariables(r)->includes(v))->size(),	varBindingRate = noBoundVars / r.variable->size(),	noWhen = r._when.predicate->size(),	noWhere = r._where.predicate->size(),	nwwp = r._when.predicate->asSet()->union(r._where.predicate->asSet())->size(),	nwwpc = r._when.predicate->asSet()->union(r._where.predicate->asSet())->select(p | p.contitionExpression.oclIsTypeOf(semanticsQvt::model::qvtrelation::RelationCallExp))->size(),	--relFanOut = calcRelOut(r._when.predicate->union(r._where.predicate->asSet())->asSet()),	--funcFanOut = calcFuncFanOut(r._when.predicate->union(r._where.predicate->asSet())->asSet()),	fanOut = calcRelFanOut(r._when.predicate->union(r._where.predicate->asSet())->asSet()),	fanIn = getFanIn(r)->size(),	valOut = calcValOut(r._when.predicate->union(r._where.predicate->asSet())->asSet())	 	};}/* Query to query */relation visitFunction {    functionName : String;    expr : semantics::model::expressions::OclExpression;        checkonly domain qvt f : semanticsQvt::model::qvtbase::Function {        name = functionName,        queryExpression = expr    };        enforce domain metrics m : QVTMetrics::Function {        name = functionName,        fanIn = semantics::model::expressions::OperationCallExp.allInstances()->select(i | i.referredOperation = f)->asSet()->size(),        fanOut = collectFunctionCallOcl(expr)->asSet()->size()    };}query collectDirectChildren(p : semanticsQvt::model::qvtbase::Transformation) : Set(semanticsQvt::model::qvtbase::Transformation) {    let t = semanticsQvt::model::qvtrelation::RelationalTransformation.allInstances()->select(i | i._extends = p) in        t}query collectChildren(p : semanticsQvt::model::qvtbase::Transformation) : Set(semanticsQvt::model::qvtbase::Transformation) {    collectDirectChildren(p)->collect(i | collectChildren(i))        ->asSet()->union(collectDirectChildren(p))}query collectParents(p : semanticsQvt::model::qvtbase::Transformation) : Set(semanticsQvt::model::qvtbase::Transformation) {    if p._extends->size() > 0 then        p._extends->union(collectParents(p._extends))    else        Set {}    endif}query countTopLevel(t:semanticsQvt::model::qvtrelation::RelationalTransformation) : Integer{	t.rule->select(r|r.oclAsType(semanticsQvt::model::qvtrelation::Relation).isTopLevel)->size()}query countStarts(t:semanticsQvt::model::qvtrelation::RelationalTransformation) : Integer{	collectStarts(t)->size()}query collectStarts(t:semanticsQvt::model::qvtrelation::RelationalTransformation) : Set(semanticsQvt::model::qvtrelation::Relation){	t.rule->select(r|r.oclIsTypeOf(semanticsQvt::model::qvtrelation::Relation))	->collect(r | r.oclAsType(semanticsQvt::model::qvtrelation::Relation))	->select( r| r.isTopLevel and r._when->size() = 0)->asSet()}query countWhen(t:semanticsQvt::model::qvtrelation::RelationalTransformation) : Integer{	  t.rule->iterate(r2: semanticsQvt::model::qvtbase::Rule; bla:Integer = 0|bla + r2.oclAsType(semanticsQvt::model::qvtrelation::Relation)._when->size())	}query countWhere(t:semanticsQvt::model::qvtrelation::RelationalTransformation) : Integer{	  t.rule->iterate(r2: semanticsQvt::model::qvtbase::Rule; bla:Integer = 0|bla + r2.oclAsType(semanticsQvt::model::qvtrelation::Relation)._where->size())	}query sumDomainCount(r:QVTMetrics::Relation) : Integer{	r.domainPattern->iterate(d:QVTMetrics::DomainPattern; acc:Integer = 0| (acc + d.domainPredicateCount.average))}--query countDomainItems(r:semanticsQvt::model::qvtrelation::Relation) : Integer--{	--r->collect(bla).oclAsType(semanticsQvt::model::qvttemplate::ObjectTemplateExp).pattern.templateExpression->size() --d. --> iterate(d:semanticsQvt::model::qvtrelation::DomainPattern; acc:Integer = 0| (acc + countItems(d.templateExpression))) --0--}query countTest(t:semanticsQvt::model::qvttemplate::TemplateExp) : Integer{	if (t.oclIsTypeOf (OclVoid) )		then 1	else		if (t.oclIsTypeOf (semanticsQvt::model::qvttemplate::ObjectTemplateExp))			then t.oclAsType(semanticsQvt::model::qvttemplate::ObjectTemplateExp).part->size()		else			0		endif	endif}query countSubExps(templ:semanticsQvt::model::qvttemplate::TemplateExp) : Integer{if (templ.oclIsTypeOf (semanticsQvt::model::qvttemplate::ObjectTemplateExp))	then templ.oclAsType(semanticsQvt::model::qvttemplate::ObjectTemplateExp).part->iterate(p:semanticsQvt::model::qvttemplate::PropertyTemplateItem; acc:Integer = 1|  acc + countSubExps(p.value.oclAsType(semanticsQvt::model::qvttemplate::TemplateExp))) else	/*Not member so try part supported by Medini*/	 if (templ.oclIsTypeOf (semanticsQvt::model::qvttemplate::ColletionTemplateExp)) then		 templ.oclAsType(semanticsQvt::model::qvttemplate::ColletionTemplateExp).part->iterate(x:semantics::model::expressions::OclExpression; acc:Integer = 1 | 		 if x.oclIsTypeOf(semanticsQvt::model::qvttemplate::TemplateExp) then		 	acc + countSubExps(x.oclAsType(semanticsQvt::model::qvttemplate::TemplateExp))		 else		 	acc		 endif		 ) 	 else		 1	 endifendif}/* valOut of a set of predicates */query calcValOut(p : Set(semanticsQvt::model::qvtbase::Predicate)) : Integer {    (p->collect(p | collectVariables(p))->asSet()        - p->collect(p | collectAssignmentVariables(p))->asSet())->size()}/* Collect all variables which are assigned in a predicate */query collectAssignmentVariables(p : semanticsQvt::model::qvtbase::Predicate) : Set(semantics::model::expressions::VariableDeclaration) {    if isAssignment(p) then        Set{p.contitionExpression.oclAsType(semantics::model::expressions::OperationCallExp).source.oclAsType(            semantics::model::expressions::VariableExp).referredVariable}    else        Set{}    endif}/* Predicate is assigment to variable */query isAssignment(p : semanticsQvt::model::qvtbase::Predicate) : Boolean {    p.contitionExpression.oclIsTypeOf(semantics::model::expressions::OperationCallExp)         and p.contitionExpression.oclAsType(semantics::model::expressions::OperationCallExp).source.oclIsTypeOf(            semantics::model::expressions::VariableExp)}/* Combined FunctionCall and RelationCall Fan out of a set of predicates */query calcFanOut(p : Set(semanticsQvt::model::qvtbase::Predicate)) : Integer {   calcRelFanOut(p)  + calcFuncFanOut(p)}/* RelationCall Fan out of a set of predicates */query calcRelFanOut(p : Set(semanticsQvt::model::qvtbase::Predicate)) : Integer {    p->collect(p | collectRelationCallExps(p)).referredRelation->asSet()->size()}/* FunctionCall Fan out of a set of predicates */query calcFuncFanOut(p : Set(semanticsQvt::model::qvtbase::Predicate)) : Integer {    p->collect(p | collectFunctionCallExps(p)).referredOperation->asSet()->size()}/* All relation calls of one predicate */query collectRelationCallExps(s : Set(semanticsQvt::model::qvtbase::Predicate)) : Set(semanticsQvt::model::qvtrelation::RelationCallExp) {    s->collect(p | collectRelationCallExps(p))->flatten().asSet()}/* All relation calls of one predicate */query collectRelationCallExps(p : semanticsQvt::model::qvtbase::Predicate) : Set(semanticsQvt::model::qvtrelation::RelationCallExp) {    collectRelationCallOcl(p.contitionExpression)}/* All relations called from p as set of RelationCallExps */ query collectRelationCallOcl(p : semantics::model::expressions::OclExpression) : Set(semanticsQvt::model::qvtrelation::RelationCallExp) {    /* Large number of different cases (ugly!) */     if (p.oclIsTypeOf(semantics::model::expressions::IfExp)) then        ---let t : semantics::model::expressions::IfExp = p.oclAsType(semantics::model::expressions::IfExp) in         collectRelationCallOcl(p.oclAsType(semantics::model::expressions::IfExp).thenExpression)->union(            collectRelationCallOcl(p.oclAsType(semantics::model::expressions::IfExp).elseExpression))->union(            collectRelationCallOcl(p.oclAsType(semantics::model::expressions::IfExp).condition))    else if (p.oclIsTypeOf(semantics::model::expressions::OperationCallExp)) then        p.oclAsType(semantics::model::expressions::OperationCallExp).arguments->collect(            p | collectRelationCallOcl(p))->asSet()    else if (p.oclIsTypeOf(semantics::model::expressions::LoopExp)) then        collectRelationCallOcl(p.oclAsType(semantics::model::expressions::LoopExp).body)->union(            collectRelationCallOcl(p.oclAsType(semantics::model::expressions::CallExp).source))    else if (p.oclIsTypeOf(semantics::model::expressions::CallExp)) then        collectRelationCallOcl(p.oclAsType(semantics::model::expressions::CallExp).source)    else if (p.oclIsTypeOf(semantics::model::expressions::VariableExp)) then        collectRelationCallOcl(p.oclAsType(semantics::model::expressions::VariableExp).referredVariable.initExpression)    else if (p.oclIsTypeOf(semanticsQvt::model::qvtrelation::RelationCallExp)) then        ---let t : semanticsQvt::model::qvtrelation::RelationCallExp = p.oclAsType(semanticsQvt::model::qvtrelation::RelationCallExp) in         Set {p.oclAsType(semanticsQvt::model::qvtrelation::RelationCallExp)}->union(            p.oclAsType(semanticsQvt::model::qvtrelation::RelationCallExp).argument->collect(                p | collectRelationCallOcl(p))->asSet())    else            Set{}    endif endif endif endif endif endif}/* All function calls of one predicate (queries) */query collectFunctionCallExps(p : semanticsQvt::model::qvtbase::Predicate) : Set(semantics::model::expressions::OperationCallExp) {    collectFunctionCallOcl(p.contitionExpression)}/* All function calls of one predicate (queries) */query collectFunctionCallExps(d : semanticsQvt::model::qvtrelation::RelationDomain) : Set(semantics::model::expressions::OperationCallExp) {    d.pattern.templateExpression->collect(t |collectFunctionCallOcl(t))->asSet()}/* All functions called from p as OperationCallExp (almost a duplicate of collectRelationCallOcl) */ query collectFunctionCallOcl(p : semantics::model::expressions::OclExpression) : Set(semantics::model::expressions::OperationCallExp) {    /* Large number of different cases (ugly!) */     if (p.oclIsTypeOf(semantics::model::expressions::IfExp)) then        ---let t : semantics::model::expressions::IfExp = p.oclAsType(semantics::model::expressions::IfExp) in         collectFunctionCallOcl(p.oclAsType(semantics::model::expressions::IfExp).thenExpression)->union(            collectFunctionCallOcl(p.oclAsType(semantics::model::expressions::IfExp).elseExpression))->union(            collectFunctionCallOcl(p.oclAsType(semantics::model::expressions::IfExp).condition))    else if (p.oclIsTypeOf(semantics::model::expressions::OperationCallExp)) then        /* Only include real QVT queries */        p.oclAsType(semantics::model::expressions::OperationCallExp).arguments->collect(p | collectFunctionCallOcl(p))->asSet()->union(            if p.oclAsType(semantics::model::expressions::OperationCallExp).referredOperation->size() > 0 then                Set{p.oclAsType(semantics::model::expressions::OperationCallExp)}            else                Set{}            endif        )    else if (p.oclIsTypeOf(semantics::model::expressions::LoopExp)) then        collectFunctionCallOcl(p.oclAsType(semantics::model::expressions::LoopExp).body)->union(            collectFunctionCallOcl(p.oclAsType(semantics::model::expressions::CallExp).source))    else if (p.oclIsTypeOf(semantics::model::expressions::CallExp)) then        collectFunctionCallOcl(p.oclAsType(semantics::model::expressions::CallExp).source)    else if (p.oclIsTypeOf(semantics::model::expressions::VariableExp)) then        collectFunctionCallOcl(p.oclAsType(semantics::model::expressions::VariableExp).referredVariable.initExpression)    else if (p.oclIsTypeOf(semanticsQvt::model::qvtrelation::RelationCallExp)) then        ---let t : semanticsQvt::model::qvtrelation::RelationCallExp = p.oclAsType(semanticsQvt::model::qvtrelation::RelationCallExp) in         p.oclAsType(semanticsQvt::model::qvtrelation::RelationCallExp).argument->collect(                p | collectFunctionCallOcl(p))->asSet()    else            Set{}    endif endif endif endif endif endif}query relationsMatchingClass(c : semantics::bridge::Classifier, t: semanticsQvt::model::qvtrelation::RelationalTransformation) : Integer{  t.rule->select(r |   					matchesClass(r._domain.oclAsType(semanticsQvt::model::qvtrelation::RelationDomain).pattern  					.oclAsType(semanticsQvt::model::qvtrelation::DomainPattern).templateExpression, c)  				)->size()}query matchesClass(templ: semanticsQvt::model::qvttemplate::TemplateExp, c: semantics::bridge::Classifier) : Boolean{	if templ.oclIsTypeOf (semanticsQvt::model::qvttemplate::ObjectTemplateExp)	then		if templ.oclAsType(semanticsQvt::model::qvttemplate::ObjectTemplateExp).refferedClass = c			then true 			else templ.oclAsType(semanticsQvt::model::qvttemplate::ObjectTemplateExp).part->exists(p |				if p.value.oclIsTypeOf(semanticsQvt::model::qvttemplate::TemplateExp) then					matchesClass(p.value.oclAsType(semanticsQvt::model::qvttemplate::TemplateExp), c)				else					false				endif				)		endif		else			if templ.oclIsTypeOf (semanticsQvt::model::qvttemplate::ColletionTemplateExp)			then templ.oclAsType (semanticsQvt::model::qvttemplate::ColletionTemplateExp).part->exists ( m | 				if m.oclIsTypeOf(semanticsQvt::model::qvttemplate::TemplateExp) then					matchesClass(m.oclAsType(semanticsQvt::model::qvttemplate::TemplateExp), c)				else					false				endif				)			else				false			endif		endif}query getFanIn(currRelation: semanticsQvt::model::qvtrelation::Relation) : Set(semanticsQvt::model::qvtrelation::Relation){	--let callExps = semanticsQvt::model::qvtrelation::RelationCallExp.allInstances()->select(i | i.referredRelation = r)->asSet() in	semanticsQvt::model::qvtrelation::Relation.allInstances()->select(r | r._where.oclIsTypeOf(semanticsQvt::model::qvtbase::Pattern))->	select(r | isFanIn(currRelation, r._where.predicate->asSet()))	}/* Fan out of a set of predicates */query isFanIn(currRelation: semanticsQvt::model::qvtrelation::Relation, p : Set(semanticsQvt::model::qvtbase::Predicate)) : Boolean {    p->collect(p | collectRelationCallExps(p))->select(x | x.referredRelation = currRelation)->size() > 0        }/* Get all leaf relations that have no where dependencies to other relations and no other relation has it in its when-clause */ query getLeafRelations(t: semanticsQvt::model::qvtrelation::RelationalTransformation) : Set( semanticsQvt::model::qvtrelation::Relation ){  t.rule->select(r | r.oclIsTypeOf(semanticsQvt::model::qvtrelation::Relation))  		->collect(r | r.oclAsType(semanticsQvt::model::qvtrelation::Relation))  		->select(r | collectRelationCallExps(r.oclAsType(semanticsQvt::model::qvtrelation::Relation)._where.predicate->asSet())->isEmpty()  					and  					semanticsQvt::model::qvtrelation::Relation.allInstances()->forAll(otherRelation |   						collectRelationCallExps(otherRelation._when.predicate->asSet())->  						select(p | p.referredRelation = r)->isEmpty() 					)  				)->asSet()}query maximum(c: Set(Integer)) : Integer{	c->iterate(v : Integer; maxi = 0 | v.max(maxi))}query calcMaxDepthLeaf(fins: Set(semanticsQvt::model::qvtrelation::Relation), visitedRelations: Set(semanticsQvt::model::qvtrelation::Relation)) : Integer{	if fins->size() > 0 then		fins->collect(lr | 			if visitedRelations->includes(lr)			then				0 /* perhaps also 1 as we might count this edge*/			else				getDepthOfLeafRelation(lr, visitedRelations->union(Set{lr}))			endif		)->iterate(v : Integer; maxi = 0 | v.max(maxi)) + 1	else		0 /* for top level it is 1 as they have a virtual node on top*/	endif}query getDepthOfLeafRelation(r: semanticsQvt::model::qvtrelation::Relation, visitedRelations: Set(semanticsQvt::model::qvtrelation::Relation)) : Integer{	calcMaxDepthLeaf(getFanIn(r), visitedRelations)}query getDepthOfLeafRelation(r: semanticsQvt::model::qvtrelation::Relation) : Integer{	let value : Integer = getDepthOfLeafRelation(r, Set{r}) in 	if value = 0 and r.isTopLevel	then		1	else		value	endif	}query collectVariableArgumentsOfRelationCallExps(p : semanticsQvt::model::qvtbase::Predicate) : Set(semantics::model::expressions::VariableDeclaration){	collectVariables(p)}query calcAvgRelationDependencyDepth(lrs: Set( semanticsQvt::model::qvtrelation::Relation )) : Real{	lrs->collect(r | getDepthOfLeafRelation(r))->sum() /  lrs->size()}query calcAvgRelationDependencyDepth(t: semanticsQvt::model::qvtrelation::RelationalTransformation) : Real{	calcAvgRelationDependencyDepth(getLeafRelations(t))}query getUnboundVariables(r: semanticsQvt::model::qvtrelation::Relation) : Set( semantics::model::expressions::VariableDeclaration){  --r._domain->collect(d |collectSingleBoundVariables(d.oclAsType(semanticsQvt::model::qvtrelation::RelationDomain)  --.pattern.templateExpression)  --)->asSet()  --->reject(v | r._when.predicate->asSet()->union(r._where.predicate->asSet())  	--		->collect(p|collectVariableArgumentsOfRelationCallExps(p))->flatten()->includes(v))	r.variable->select(v | v.variableExps->isEmpty())->asSet() /*v.refferingExp when used on standard*/}--Retrieves only those Variables that occur only once in a bindingquery collectSingleBoundVariables(templ: semanticsQvt::model::qvttemplate::TemplateExp) : Set( semantics::model::expressions::VariableDeclaration ){  if templ.oclIsTypeOf (semanticsQvt::model::qvttemplate::ObjectTemplateExp)	  then templ.oclAsType(semanticsQvt::model::qvttemplate::ObjectTemplateExp).part->collect(p |			  if p.value.oclIsTypeOf(semanticsQvt::model::qvttemplate::TemplateExp) then				  collectVariables(p.value.oclAsType(semanticsQvt::model::qvttemplate::TemplateExp))				else			    Set {}				endif			)->asOrderedSet()		  ->symmetricDifference(templ.bindsTo->asOrderedSet())->asSet()	else /* Not supported by medini? lets try part instead of member */	  if templ.oclIsTypeOf (semanticsQvt::model::qvttemplate::ColletionTemplateExp)	  then templ.oclAsType (semanticsQvt::model::qvttemplate::ColletionTemplateExp).part->collect ( m | /*was .member*/			if m.oclIsTypeOf(semanticsQvt::model::qvttemplate::TemplateExp) then			  collectVariables(m.oclAsType(semanticsQvt::model::qvttemplate::TemplateExp))			else			  Set {}			endif		)->asOrderedSet()			->symmetricDifference(templ.bindsTo->asOrderedSet())->asSet()	  else	   Set{ templ.bindsTo }	  endif  endif}/* Collect variables of template Exps */query collectVariables(p : semanticsQvt::model::qvttemplate::TemplateExp) : Set(semantics::model::expressions::VariableDeclaration) {	if p.oclIsTypeOf(semanticsQvt::model::qvttemplate::ObjectTemplateExp)	then p.oclAsType(semanticsQvt::model::qvttemplate::ObjectTemplateExp).part->collect(p |			if p.value.oclIsTypeOf(semanticsQvt::model::qvttemplate::TemplateExp) then				  collectVariables(p.value.oclAsType(semanticsQvt::model::qvttemplate::TemplateExp))			else			    Set {}			endif			)->asSet()->union( Set {p.bindsTo})else	Set {p.bindsTo}endif}/* Collect variables of relation calls */query collectVariables(p : semanticsQvt::model::qvtbase::Predicate) : Set(semantics::model::expressions::VariableDeclaration) {    /* Only directly used variable are assigned in a relation call, ignore stuff like iterators */    collectRelationCallExps(p).argument->select(i | i.oclIsTypeOf(semantics::model::expressions::VariableExp))->collect(        i | i.oclAsType(semantics::model::expressions::VariableExp)).referredVariable->asSet()}/* Balance of child */query calcInheritComplexity(t: semanticsQvt::model::qvtbase::Transformation) : Real {    t.rule->size() + t.rule->collect(i | i._domain->size())->sum()}query calcAvgWhen(t:QVTMetrics::Transformation) : Real{	  t.relations.noWhen->sum() / t.relations->size()}query calcAvgWhere(t:QVTMetrics::Transformation) : Real{	  t.relations.noWhere->sum() / t.relations->size()}query calcAvgNWWPC(t:QVTMetrics::Transformation) : Real{	  t.relations.nwwpc->sum() / t.relations->size()}query calcAvgNWWP(t:QVTMetrics::Transformation) : Real{	  t.relations.nwwp->sum() / t.relations->size()}query calcAvgDomains(t:QVTMetrics::Transformation) : Real{	  t.relations.noDomains->sum() / t.relations->size()}query calcAvgSizeOfDomainPattern(t:QVTMetrics::Transformation) : Real{	  t.relations->collect(r | r.avgSizeOfDomainPattern)->sum() / t.relations->size()}query calcAvgVars(t:QVTMetrics::Transformation) : Real{	  t.relations.noVars->sum() / t.relations->size()}query calcAvgCheckonlyDomains(t:QVTMetrics::Transformation) : Real{	  t.relations.noCheckonlyDomains->sum() / t.relations->size()}query calcAvgRelFanOut(t:QVTMetrics::Transformation) : Real{      (t.relations.fanOut->sum())       / (t.relations->size())}query calcAvgFuncFanOut(t:QVTMetrics::Transformation) : Real{      (t.functions.fanOut->sum())       / (t.functions->size())}query calcAvgFanIn(t:QVTMetrics::Transformation) : Real{      (t.relations.fanIn->sum() + t.functions.fanIn->sum()) / (t.relations->size() + t.functions->size())}query calcAvgValOut(t:QVTMetrics::Transformation) : Real{      t.relations->collect(r | r.valOut)->sum() / t.relations->size()}query calcAvgEnforcedDomains(t:QVTMetrics::Transformation) : Real{	t.relations.noEnforcedDomains->sum()/ t.relations->size()}query calcAvgVariableBindingRate(t:QVTMetrics::Transformation) : Real{	 t.relations.varBindingRate->sum() / t.relations->size()}query AvSDP(t: semanticsQvt::model::qvtbase::Transformation) : Real{	AvSDP(t.rule._domain) 	}query AvSDP(d: Sequence(semanticsQvt::model::qvtbase::Domain)) : Real{	d->collect(d | SDP(d))->sum() / d->size()}query SDP(d: semanticsQvt::model::qvtbase::Domain) : Integer{	countSubExps(d.oclAsType(semanticsQvt::model::qvtrelation::RelationDomain).pattern.templateExpression)}/* Complexity of children */query calcAvgChildComplexity(t: semanticsQvt::model::qvtbase::Transformation) : Real{    collectDirectChildren(t)->collect(i | calcInheritComplexity(i))->sum() / collectDirectChildren(t)->size()}query calcAvgTypeOverlap(t: semanticsQvt::model::qvtrelation::RelationalTransformation) : Real{    calcAvgTypeOverlap(semantics::bridge::Classifier.allInstances(), t)}query calcAvgTypeOverlap(clazzes: Set(semantics::bridge::Classifier), t: semanticsQvt::model::qvtrelation::RelationalTransformation) : Real{   clazzes->collect(c | relationsMatchingClass(c, t))->sum() / clazzes->size()}}    